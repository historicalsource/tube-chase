	.TITLE TCSOUN
	.RADIX 16
	.CSECT TCSOUN
	.ENABLE AMA
	.REPT 0
*****************************************
*
*POKEY SOUND SYSTEM CONTROL
*
*PROJECT #: 16703 (TUBE CHASE)
*HARDWARE: A CORECTLY INSTALLED POKEY
*
*DESCRIPTION:	THIS CONTAINS 2 ROUTINES:
*		 1) THE FIRST ROUTINE STARTS A SOUND.
*		    IT MAY BE CALLED ANYTIME, BUT CERTAIN
*		    PRIORITY RULES ON SOUNDS APPLY (SEE ROUTINE)
*		 2) THE SECOND MUST BE CALLED ONCE EVERY 16 MSEC
*		    (OR 1 FRAME). THIS ROUTINE CONTINUES A SOUND.
*		    IT ALSO SHUTS THINGS UP WHEN DONE.
*
******************************************
*
*PROGRAMMER:	OWEN RUBIN
*
******************************************
	.ENDR
	.PAGE
	.SBTTL GLOBLS
;ENTRY POINTS (AS SUBROUTINES)
	.GLOBL STSOUND,CSOUND
;RAM CELLS (DOES NOT HAVE TO BE 0 PAGE)
	.GLOBL SSTAT,SOUNDN,POINT,CURRENT,FRAMES,COUNT,STATE,LOCKOUT
;EXTERNAL REFERENCES (SUCH AS POKEY)
	.GLOBL AUDF1,AUDCTL
;SOUND NAMES
	.GLOBL EXPLOS,PHASER
	.SBTTL USPAGE
	.REPT 0
HOW TO USE THIS PROGRAM:
I) RAM MUST BE ALLOCATED AND DEFINED 'GLOBL' AS DESCRIBED
   UNDER 'RAM & ROM ALLOCATION'.
II) EACH SOUND IS DESCRIBED BY A TABLE.
	A) THE TABLE IS A GROUP OF CHANNEL SEQUENCE
	   1) A CHANNEL SEQUENCE IS A SET OF 4 BYTES (POSSIBLE 2)
	      AS DESCRIBED UNDER 'RAM & ROM ALLOCATION'.
	B) THIS ROUTINE WILL HANDLE 6 CHANNELS (WHICH IS 3 POKEY
	   SOUND CHANNELS) AS EACH POKEY CHANNEL CONSISTS OF A
	   FREQUENCY CONTROL CHANNEL AND AN AUDIO CONTROL CHANNEL.
	   1) BOTH POKEY CHANNELS ARE HANDLED EXACTLY THE SAME
	      BY THIS ROUTINE AS BOTH USUALLY REQUIRE SOME SEQUENCE
	      TO BE OUTPUTED.
	C) EACH CHANNEL WITHIN A SOUND IS DESCRIBED BY A NAME
	   (UP TO 5 CHARS) PLUS A NUMBER (WHICH DESCRIBES WHICH
	   CHANNEL IT IS).
III) MAKING NOISE
	A) DEFINE THE SEQUENCE OF NUMBERS WHICH WILL GO OUT TO EACH
	   CHANNEL.  IF A CHANNEL IS NOT GOING TO BE USED, OR IS
	   NOT GOING TO CHANGE, DECIDE WHAT VALUE YOU WANT OUTPUT 
	   TO THIS CHANNEL WHILE THE SOUND IS RUNNING.
	   IF NOT DESCRIBED, 0 WILL BE OUTPUT
	   A CHANGE CAN HAPPEN EVER INTERRUPT
	B) TAME THE SEQUENCE AND CONVERT IT INTO THE 4 BYTE
	   SEQUENCE AS PREVIOUSLY DESCRIBED (SEE UNDER 'RAM &
	   ROM ALLOCATION'). PUT THE PROPER LABEL IN FRONT OF
	   EACH GROUP OF 4 BYTE SEQUENCES.
	   *NOTE: THE LONGEST SEQUENCE IS ALWAYS DEFINED AS 
	    CHANNEL 1.
	C) END EACH SEQUENCE WITH .BYTE 0,0 & ADD LABLES
	D) PLACE AN ENTRY INTO THE 'PNTRS' AREA USING THE 
	   'OFFSET' MACRO. THE HIGHER IN THIS TABLE, THE
	   HIGHER THE PRIORITY OF THE SOUND.
	F) THE DATA TABLES FOR SOUNDS MAY FOLLOW 'SOUND':
	   .BYTE 0' ANYWHERE WITHIN 255 BYTES TOTAL
	
EXAMPLE:
A) SEQUENCES
   1) 1ST SEQUNCE FREQUENCY:(43,83,0C3,03) REPEATED 124 TIMES,
      CHANGING ONCE A FRAME.
   2) CORRESPONDING CONTROL REGISTER IS ALWAYS 0
   3) 2ND SEQUENCE, FREQUENCEY: 1,2,3,4,5 UP TO 45 CHANGING EVERY
      4 FRAMES.
   4) CORRESPONDING CONTROL SEQUENCE: 0AF ANF 7 FRAMES
				      8F FOR 90 FRAMES
				      8E DOWN TO 80 CHANNEL EVERY FRAME
B) CONVERSION: (INTERREPT 4 TIMES A FRAME)
   1) 1ST SEQUENCE		.BYTE 43,4,40,124.
   2) CONTROL CHANNEL		.BYTE 0,0
   3) 2ND SEQUENCE		.BYTE 1,16.,1,45.
   4) CONTROL CHANNEL		.BYTE 0AF,28,0,1
				.BYTE 8F,4,0,90. ;NOTE* BOTH WAYS OF DONG THIS
				.BYTE 8E,4,-1,15.
C) ENDING:
	CH1:	.BYTE 43,4,40,124.
		.BYTE 0,0
	CH2:	.BYTE 0,0
	CH3:	.BYTE 1,16.,1,45.
		.BYTE 0,0
	CH4:	.BYTE 0AF,28,0,1
		.BYTE 8F,4,0,90.
		.BYTE 8E,4,-1,15.
		.BYTE 0,0
D) POINTERS:
	PNTRS: OFFSET CH
F) PLACE SECTION C UNDER:
	SOUND: .BYTE 0
	.ENDR
	.PAGE
	.SBTTL RAM & ROM ALLOCATION
	.REPT 0
*THE FOLLOWING MUST BE DEFINED SOME WHERE IN YOUR RAM ALLOCATION
*SOUND ROUTINE VARIABLES
	
SSTAT:	.BLKB 1			;SOUND STATUS POINTER. - IS ACTIVE
SOUNDN:	.BLKB 1			;SOUND # IN PROGRESS
POINT:	.BLKB 6			;POINTER OFFSET INTO DATA TABLES(IF 0, CHANNEL NOT ACTIVE)
CURRENT:.BLKB 6			;OUTPUT VALUE
FRAMES:	.BLKB 6			;FRAMES UNTIL NEXT CHANGE
COUNT:	.BLKB 6			;COUNT OF TOTAL CHANGES
	.ENDR
;***DATA TABLES DESCRIPTION***
;EACH TABLE ENTRY IS 4 BYTES DESCRIBING A SEQUENCE, CONSISTING OF:
STVAL	=0			;VALUE TO START SEQUENCE
FRCNT	=1			;# OF FRAMES BEFORE ANY CHANGE
CHANGE	=2			;AMOUNT OF CHANGE
NUMBER	=3			;TOTAL NUMBER OF CHANGES IN THIS SEQUENCE
;EX1: 0FF,1,-1,6 DESCRIBES THE FOLLOWING SEQUENCE
;	0FF,0FE,0FD,0FC,0FB,0FA,0F9
;EX2: 0,45,0,1 WILL OUTPUT 0 FOR 46 FRAMES
;
;IF A 0 IS PUT INTO 'FRCNT', THE VALUE OF 'STVAL' WILL BE OUTPUT
;CONTINIOUSLY. UNTIL CH1 IS ENDED (THIS FEATURE MAY NOT BE USED ON CH1
;IF THIS FEATURE IS USED, ONLY THE FIRST 2 BYTES (STVAL & FRCNT)
;NEED BE DEFINED FOR THAT ENTRY
;WHEN A 0 IS PUT IN 'FRCNT' FOR CH1, THE TOTAL SOUND
;(ALL 6 CHANNELS) ENDS & ALL CHANNELS RETURN TO WHATEVER IS IN 'IDLEV'
	.PAGE
	.SBTTL OFFSET MACROS FOR SOUND ROUTINES
	.MACRO OFFSET,LABEL
	.IRPC X,<123456>
	.IF DF,LABEL''X
	.BYTE LABEL''X-SOUND
	.IFF
	.BYTE 0
	.ENDC
	.ENDR
	.ENDM
;
;THE ABOVE MACRO GENERATES THE OFFSETS FROM THE 'SOUND' BASE ADDRESS
;FOR A CHANNEL OF DATA.
;IF LESS THAN 6 CHANNELS ARE USED, THE REMAINING POINTERS ARE SET TO 0
;A 0 VALUE POINTER INDICATES AN IDLE CHANNEL.
;
;EX: SOUND: .BYTE 0
;
;    CH1:   .BYTE 0,45,0,1
;    CH2:   .BYTE 0,45,0,2,3,7,9,1
;
;BY CALLING 'OFFSET CH' , THE FOLLOWING WILL BE PLACED IN LINE
;	    .BYTE CH1-SOUND
;	    .BYTE CH2-SOUND
;	    .BYTE 0,0,0,0
;
	.PAGE
	.SBTTL SOUND TABLES
;TABLES OF OFFSET POINTER FOR SOUNDS. (6 BYTES PER SOUND NUMBER)
PNTRS:	OFFSET EX
	OFFSET PH
PTLEN	=.-PNTRS
EXPLOS	=0
PHASER	=1
	
;SOUND TABLES
SOUND:	.BYTE 0			;THIS 0 IS SO NO OFFSET POINTER WILL BE 0
				;A GOOD PLACE FOR THE CHECKSUM
;DATA STRUCTUREJ:
;A CHANNEL CONSISTS OF A SERIES OF 4 BYTE SEQUENCES:
;	BYTE		FUNCTION
;	 1		 STARTING VALUE OF SEQUENCE
;	 2		 # OF INTERRUPS BEFORE NEXT CHANGE
;	 3		 AMOUNT OF CHANGE
;	 4		 TOTAL NUMBER OF CHANGES (# OF DIFFERENT VALUES)
;TO STOP A CHANNEL & RETURN TO ITS IDLE STATE, PUT IN AS A
;2 BYTE SEQUENCE X,0 WHERE X WILL BE USED AS THE NEW IDLE VALUE.
;NOTE: ALL SOUNDS END WHEN CHANNEL 1 GOES IDLE, SO IT SHOULD BE THE
;LONGEST
;
;EXPLOSION SOUND
;
EX1:	.BYTE 43,4,40,104.
	.BYTE 0,0
EX3:	.BYTE 1,16.,1,26.
	.BYTE 1F,0
EX4:	.BYTE 0AF,28.,0,1
	.BYTE 8F,4,0,90.
	.BYTE 8E,4,-1,2
	.BYTE 8D,8,0,1
	.BYTE 8D,4,-1,4
	.BYTE 8A,12.,0,1
	.BYTE 89,4,-1,3
	.BYTE 87,12.,0,1
	.BYTE 86,4,-1,3
	.BYTE 84,12.,0,1
	.BYTE 83,4,-1,4
	.BYTE 80,0
EX5:	.BYTE 4,0
EX6:	.BYTE 88,4,0,90.
	.BYTE 87,8,-1,3
	.BYTE 85,4,-1,6
	.BYTE 80,0
;
;PHASER SOUND
;
PH1:	.BYTE 0FF,4,-1,7
	.BYTE 1,4,-1,39.
	.BYTE 0C0,0
PH3:	.BYTE 2,4,1,7
	.BYTE 3,4,1,2
	.BYTE 4,4,1,37.
	.BYTE 1F,0
PH4:	.BYTE 0A0,28.,0,1
	.BYTE 0AF,40.,0,1
	.BYTE 0AE,8,-1,14.
	.BYTE 80,0
PH5:	.BYTE 0,4,4,2
	.BYTE 4,1,3,2
	.BYTE 1,4,3,2
	.BYTE 0,4,0,40.
	.BYTE 0FE,0
PH6:	.BYTE 83,4,2,7
	.BYTE 8A,20.,0,1
	.BYTE 89,8,-1,9.
	.BYTE 80,48.,0,1
	.BYTE 80,0
	.PAGE
	.SBTTL START SOUND ROUTINE
;
;PASS SOUND NUMBER IN 'X'.
;IF NO SOUND IS ACTIVE, THE NEW SOUND WILL START
;IF THE SOUND ACTIVE IS THE SAME SOUND THAT IS TO BE STARTED, IT WILL RESTART
;IF A SOUND IS ACTIVE, THE NEW SOUND WILL START ONLY IF IT HAS A HIGHER
; PRIORITY THAN THE CURRENT SOUND (A SOUND # LESS THAN THE CURRENT SOUND)
;
STSOUND:BIT STATE		;NO SOUNT IF ATTRACT
	BMI 40$	
	BIT SSTAT		;SOUND ACTIVE?
	BPL 20$			;NO IF +
	CPX SOUNDN		;CHECK PRIORITY LEVEL
	BEQ 20$			;IF SAME, RESTART
	BCC 20$			;IF HIGHER PRIORITY, RESTART
	LDA I,0
	LDY I,5
10$:	ORA Y,POINT
	DEY
	BPL 10$
	TAY			;ALL POINTERS 0?
	BEQ 20$			;IF YES, START SOUND
	RTS			;ELSE SKIP SOUND
20$:	STX SOUNDN		;SAVE SOUND NUMBER
	LSR SSTAT			;MAKE SSTAT PLUS
	LDA I,80
	STA LOCKOUT		;LOCKOUT INTERRUPTS
	LDX I,5			;TURN OFF OLD SOUND
	LDA I,0			;QUIET OLD SOUNDS
25$:	STA X,CURRENT		;SET CURRENT & IDLE VALUE
	STA X,AUDF1		;OUTPUT TO POKEY
	DEX			;6 'CHANNELS'
	BPL 25$
	LDA SOUNDN		;SOUND X1
	ASL			;X2 & CLC
	ADC SOUNDN		;X3
	ASL			;X6, CLC
	ADC I,5			;BECAUSE IT COUNTS DOWN, NOT UP
	TAY			;POINTER TO INITIAL POINTER
	CPY I,PTLEN+5		;NO SUCH SOUND NUMBER
	BCS 40$
	LDX I,5
30$:	LDA Y,PNTRS
	STA X,POINT
	LDA I,1
	STA X,FRAMES		;SET UP FOR INIT OF SOUND
	STA X,COUNT
	DEY
	DEX
	BPL 30$
	STX SSTAT		;SET ACTIVE
	STA LOCKOUT		;RELEASE INTERRUPT LOCK
40$:	RTS
	.PAGE
	.SBTTL SOUND ROUTINE
;
;CONTINUES A PREVIOUSLY STARTED SOUND
;WHEN CHANNEL 1 GOES IDLE, ALL SOUND ENDS
;
CSOUND:	LDX I,5			;6 CHANNELS
	BIT SSTAT
	BMI 10$			;OK TO OUTPUT
	BIT LOCKOUT
	BMI 16$			;LEAVE ALONE
	BPL 15$			;ELES SHUT-UP
10$:	DEC X,FRAMES		;CHANGE THIS FRAME
	BNE 30$
	LDY X,POINT		;GET DATA POINTER
	BEQ 30$			;NOT ACTIVE CHANNEL
	DEC X,COUNT		;DATA CHANGES LEFT?
	BNE 20$			;NO -- NONE
	LDA Y,SOUND+STVAL	;GET CURRENT VALUE
	STA X,CURRENT		;SAVE
	LDA Y,SOUND+FRCNT	;GET FRAMES OF THIS LEVEL
	STA X,FRAMES		;UPDATE FRAME NUMBER
	BNE 17$			;IF 0, THIS CHANNEL JUST ENDED
	STA X,POINT		;SET POINTER TO 0 TO IDLE CHANNEL
	TXA			;A CHEAP WAY TO TEST IF THIS IS CH 1
	BNE 30$			;IF NOT CH 1, JUST IDLE CHANNEL
	LDX I,5
15$:	LDA I,0			;ALL SOUND CHANNELS TO 0 VALUE WHEN OFF
14$:	STA X,CURRENT
	STA X,AUDF1
	STA X,POINT		;ALL POINTER TO 0
	DEX
	BPL 14$
	STA SSTAT			;TURN OFF STATUS TOO
16$:	RTS
17$:	LDA Y,SOUND+NUMBER
	STA X,COUNT		;# OF CHANGES
	LDA X,POINT
	CLC
	ADC I,4			;POINT TO NEXT SEQUENCE
	STA X,POINT
	BNE 30$			;BETTER BE ALWAYS****
20$:	LDA Y,SOUND+FRCNT-4	;FRAME RATE
				;THE -4 TO CORRECT FOR THE POINTER BEING ALREADY
				;INCREMENTED TO POINT TO THE NEXT BLOCK.
	STA X,FRAMES
	LDA X,CURRENT
	CLC
	ADC Y,SOUND+CHANGE-4	;STEP THRU SEQUENCE
	STA X,CURRENT
30$:	LDA X,CURRENT		;MORE THAN 1 PATH HERE SO LOAD CURRENT
	STA X,AUDF1		;OUTPUT
	LDA I,50
	STA AUDCTL
	DEX
	BPL 10$
	RTS
	.END
                                                                                                                                                                                                                                                                                                                                                                                                                                                      